{"ast":null,"code":"function parseAllocRate(str) {\n  // Handles values like '11mb/s', '2361kb/s', '1423b/s'\n  const match = str.trim().match(/([\\d.]+)\\s*(mb|kb|b)\\/s/i);\n  if (!match) return 0;\n  const value = parseFloat(match[1]);\n  const unit = match[2].toLowerCase();\n  if (unit === 'mb') return value * 1024 * 1024;\n  if (unit === 'kb') return value * 1024;\n  if (unit === 'b') return value;\n  return 0;\n}\nexport function parseJvmThreadDump(content) {\n  const blocks = content.split(/\\n\\s*\\n/).map(b => b.trim()).filter(Boolean);\n  const results = [];\n  for (const block of blocks) {\n    const lines = block.split(/\\n/).map(l => l.trim()).filter(Boolean);\n    if (lines.length < 6) continue;\n\n    // Parse header\n    const timestampMatch = lines[0].match(/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\+\\d{4})/);\n    const cpuMatch = lines[1].match(/process cpu=([\\d.]+)%/);\n    const heapAllocMatch = lines[5].match(/heap allocation rate ([^\\s]+)/i);\n    if (!timestampMatch || !cpuMatch || !heapAllocMatch) continue;\n    const timestamp = Date.parse(timestampMatch[1]);\n    const cpuUsage = parseFloat(cpuMatch[1]);\n    const heapAllocRate = parseAllocRate(heapAllocMatch[1]);\n\n    // Parse threads\n    const threads = [];\n    for (let i = 6; i < lines.length; i++) {\n      const threadLine = lines[i];\n      const threadMatch = threadLine.match(/^\\[(\\d+)\\] user=\\s*([\\-\\d.]+)% sys=\\s*([\\-\\d.]+)% alloc=\\s*([^\\s]+) - (.+)$/);\n      if (threadMatch) {\n        const id = threadMatch[1];\n        const userCpu = parseFloat(threadMatch[2]);\n        const sysCpu = parseFloat(threadMatch[3]);\n        const allocRate = parseAllocRate(threadMatch[4]);\n        const name = threadMatch[5].trim();\n        // State is not present, so we can set it as 'UNKNOWN' or parse from name if needed\n        threads.push({\n          id,\n          name,\n          state: 'UNKNOWN',\n          cpuUsage: userCpu + sysCpu,\n          allocRate\n        });\n      }\n    }\n    results.push({\n      timestamp,\n      cpuUsage,\n      heapAllocRate,\n      threads\n    });\n  }\n  return results;\n}","map":{"version":3,"names":["parseAllocRate","str","match","trim","value","parseFloat","unit","toLowerCase","parseJvmThreadDump","content","blocks","split","map","b","filter","Boolean","results","block","lines","l","length","timestampMatch","cpuMatch","heapAllocMatch","timestamp","Date","parse","cpuUsage","heapAllocRate","threads","i","threadLine","threadMatch","id","userCpu","sysCpu","allocRate","name","push","state"],"sources":["/Users/swapnilbhisey/github/jvm-thread-visualizer/src/utils/parser.ts"],"sourcesContent":["export interface ThreadStats {\n  id: string;\n  name: string;\n  state: string;\n  cpuUsage: number;\n  allocRate: number;\n}\n\nexport interface ProcessSummary {\n  timestamp: number;\n  cpuUsage: number;\n  heapAllocRate: number;\n  threads: ThreadStats[];\n}\n\nfunction parseAllocRate(str: string): number {\n  // Handles values like '11mb/s', '2361kb/s', '1423b/s'\n  const match = str.trim().match(/([\\d.]+)\\s*(mb|kb|b)\\/s/i);\n  if (!match) return 0;\n  const value = parseFloat(match[1]);\n  const unit = match[2].toLowerCase();\n  if (unit === 'mb') return value * 1024 * 1024;\n  if (unit === 'kb') return value * 1024;\n  if (unit === 'b') return value;\n  return 0;\n}\n\nexport function parseJvmThreadDump(content: string): ProcessSummary[] {\n  const blocks = content.split(/\\n\\s*\\n/).map(b => b.trim()).filter(Boolean);\n  const results: ProcessSummary[] = [];\n\n  for (const block of blocks) {\n    const lines = block.split(/\\n/).map(l => l.trim()).filter(Boolean);\n    if (lines.length < 6) continue;\n\n    // Parse header\n    const timestampMatch = lines[0].match(/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\+\\d{4})/);\n    const cpuMatch = lines[1].match(/process cpu=([\\d.]+)%/);\n    const heapAllocMatch = lines[5].match(/heap allocation rate ([^\\s]+)/i);\n    if (!timestampMatch || !cpuMatch || !heapAllocMatch) continue;\n\n    const timestamp = Date.parse(timestampMatch[1]);\n    const cpuUsage = parseFloat(cpuMatch[1]);\n    const heapAllocRate = parseAllocRate(heapAllocMatch[1]);\n\n    // Parse threads\n    const threads: ThreadStats[] = [];\n    for (let i = 6; i < lines.length; i++) {\n      const threadLine = lines[i];\n      const threadMatch = threadLine.match(/^\\[(\\d+)\\] user=\\s*([\\-\\d.]+)% sys=\\s*([\\-\\d.]+)% alloc=\\s*([^\\s]+) - (.+)$/);\n      if (threadMatch) {\n        const id = threadMatch[1];\n        const userCpu = parseFloat(threadMatch[2]);\n        const sysCpu = parseFloat(threadMatch[3]);\n        const allocRate = parseAllocRate(threadMatch[4]);\n        const name = threadMatch[5].trim();\n        // State is not present, so we can set it as 'UNKNOWN' or parse from name if needed\n        threads.push({\n          id,\n          name,\n          state: 'UNKNOWN',\n          cpuUsage: userCpu + sysCpu,\n          allocRate,\n        });\n      }\n    }\n\n    results.push({\n      timestamp,\n      cpuUsage,\n      heapAllocRate,\n      threads,\n    });\n  }\n\n  return results;\n} "],"mappings":"AAeA,SAASA,cAAcA,CAACC,GAAW,EAAU;EAC3C;EACA,MAAMC,KAAK,GAAGD,GAAG,CAACE,IAAI,CAAC,CAAC,CAACD,KAAK,CAAC,0BAA0B,CAAC;EAC1D,IAAI,CAACA,KAAK,EAAE,OAAO,CAAC;EACpB,MAAME,KAAK,GAAGC,UAAU,CAACH,KAAK,CAAC,CAAC,CAAC,CAAC;EAClC,MAAMI,IAAI,GAAGJ,KAAK,CAAC,CAAC,CAAC,CAACK,WAAW,CAAC,CAAC;EACnC,IAAID,IAAI,KAAK,IAAI,EAAE,OAAOF,KAAK,GAAG,IAAI,GAAG,IAAI;EAC7C,IAAIE,IAAI,KAAK,IAAI,EAAE,OAAOF,KAAK,GAAG,IAAI;EACtC,IAAIE,IAAI,KAAK,GAAG,EAAE,OAAOF,KAAK;EAC9B,OAAO,CAAC;AACV;AAEA,OAAO,SAASI,kBAAkBA,CAACC,OAAe,EAAoB;EACpE,MAAMC,MAAM,GAAGD,OAAO,CAACE,KAAK,CAAC,SAAS,CAAC,CAACC,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACV,IAAI,CAAC,CAAC,CAAC,CAACW,MAAM,CAACC,OAAO,CAAC;EAC1E,MAAMC,OAAyB,GAAG,EAAE;EAEpC,KAAK,MAAMC,KAAK,IAAIP,MAAM,EAAE;IAC1B,MAAMQ,KAAK,GAAGD,KAAK,CAACN,KAAK,CAAC,IAAI,CAAC,CAACC,GAAG,CAACO,CAAC,IAAIA,CAAC,CAAChB,IAAI,CAAC,CAAC,CAAC,CAACW,MAAM,CAACC,OAAO,CAAC;IAClE,IAAIG,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;;IAEtB;IACA,MAAMC,cAAc,GAAGH,KAAK,CAAC,CAAC,CAAC,CAAChB,KAAK,CAAC,sDAAsD,CAAC;IAC7F,MAAMoB,QAAQ,GAAGJ,KAAK,CAAC,CAAC,CAAC,CAAChB,KAAK,CAAC,uBAAuB,CAAC;IACxD,MAAMqB,cAAc,GAAGL,KAAK,CAAC,CAAC,CAAC,CAAChB,KAAK,CAAC,gCAAgC,CAAC;IACvE,IAAI,CAACmB,cAAc,IAAI,CAACC,QAAQ,IAAI,CAACC,cAAc,EAAE;IAErD,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACL,cAAc,CAAC,CAAC,CAAC,CAAC;IAC/C,MAAMM,QAAQ,GAAGtB,UAAU,CAACiB,QAAQ,CAAC,CAAC,CAAC,CAAC;IACxC,MAAMM,aAAa,GAAG5B,cAAc,CAACuB,cAAc,CAAC,CAAC,CAAC,CAAC;;IAEvD;IACA,MAAMM,OAAsB,GAAG,EAAE;IACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,KAAK,CAACE,MAAM,EAAEU,CAAC,EAAE,EAAE;MACrC,MAAMC,UAAU,GAAGb,KAAK,CAACY,CAAC,CAAC;MAC3B,MAAME,WAAW,GAAGD,UAAU,CAAC7B,KAAK,CAAC,6EAA6E,CAAC;MACnH,IAAI8B,WAAW,EAAE;QACf,MAAMC,EAAE,GAAGD,WAAW,CAAC,CAAC,CAAC;QACzB,MAAME,OAAO,GAAG7B,UAAU,CAAC2B,WAAW,CAAC,CAAC,CAAC,CAAC;QAC1C,MAAMG,MAAM,GAAG9B,UAAU,CAAC2B,WAAW,CAAC,CAAC,CAAC,CAAC;QACzC,MAAMI,SAAS,GAAGpC,cAAc,CAACgC,WAAW,CAAC,CAAC,CAAC,CAAC;QAChD,MAAMK,IAAI,GAAGL,WAAW,CAAC,CAAC,CAAC,CAAC7B,IAAI,CAAC,CAAC;QAClC;QACA0B,OAAO,CAACS,IAAI,CAAC;UACXL,EAAE;UACFI,IAAI;UACJE,KAAK,EAAE,SAAS;UAChBZ,QAAQ,EAAEO,OAAO,GAAGC,MAAM;UAC1BC;QACF,CAAC,CAAC;MACJ;IACF;IAEApB,OAAO,CAACsB,IAAI,CAAC;MACXd,SAAS;MACTG,QAAQ;MACRC,aAAa;MACbC;IACF,CAAC,CAAC;EACJ;EAEA,OAAOb,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}