{"ast":null,"code":"function parseAllocRate(str) {\n  // Handles values like '11mb/s', '2361kb/s', '1423b/s'\n  const match = str.trim().match(/([\\d.]+)\\s*(mb|kb|b)\\/s/i);\n  if (!match) return 0;\n  const value = parseFloat(match[1]);\n  const unit = match[2].toLowerCase();\n  let bytes = 0;\n  if (unit === 'mb') bytes = value * 1024 * 1024;else if (unit === 'kb') bytes = value * 1024;else if (unit === 'b') bytes = value;\n  // Filter out values above 10,000 MB/s (10,000 * 1024 * 1024 bytes)\n  if (bytes > 10000 * 1024 * 1024) return 0;\n  return bytes;\n}\nexport function parseJvmThreadDump(content) {\n  const blocks = content.split(/\\n\\s*\\n/).map(b => b.trim()).filter(Boolean);\n  const results = [];\n  for (const block of blocks) {\n    const lines = block.split(/\\n/).map(l => l.trim()).filter(Boolean);\n    if (lines.length < 6) continue;\n\n    // Parse header\n    const timestampMatch = lines[0].match(/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\+\\d{4})/);\n    const cpuMatch = lines[1].match(/process cpu=([\\d.]+)%/);\n    const heapAllocMatch = lines[5].match(/heap allocation rate ([^\\s]+)/i);\n    if (!timestampMatch || !cpuMatch || !heapAllocMatch) continue;\n    const timestamp = Date.parse(timestampMatch[1]);\n    const cpuUsage = parseFloat(cpuMatch[1]);\n    const heapAllocRate = parseAllocRate(heapAllocMatch[1]);\n\n    // Parse threads\n    const threads = [];\n    for (let i = 6; i < lines.length; i++) {\n      const threadLine = lines[i];\n      const threadMatch = threadLine.match(/^\\[(\\d+)\\] user=\\s*([\\-\\d.]+)% sys=\\s*([\\-\\d.]+)% alloc=\\s*([^\\s]+) - (.+)$/);\n      if (threadMatch) {\n        const id = threadMatch[1];\n        const userCpu = parseFloat(threadMatch[2]);\n        const sysCpu = parseFloat(threadMatch[3]);\n        const allocRate = parseAllocRate(threadMatch[4]);\n        const name = threadMatch[5].trim();\n        // State is not present, so we can set it as 'UNKNOWN' or parse from name if needed\n        threads.push({\n          id,\n          name,\n          state: 'UNKNOWN',\n          cpuUsage: userCpu + sysCpu,\n          allocRate\n        });\n      }\n    }\n    results.push({\n      timestamp,\n      cpuUsage,\n      heapAllocRate,\n      threads\n    });\n  }\n  return results;\n}","map":{"version":3,"names":["parseAllocRate","str","match","trim","value","parseFloat","unit","toLowerCase","bytes","parseJvmThreadDump","content","blocks","split","map","b","filter","Boolean","results","block","lines","l","length","timestampMatch","cpuMatch","heapAllocMatch","timestamp","Date","parse","cpuUsage","heapAllocRate","threads","i","threadLine","threadMatch","id","userCpu","sysCpu","allocRate","name","push","state"],"sources":["/Users/swapnilbhisey/github/jvm-thread-visualizer/src/utils/parser.ts"],"sourcesContent":["export interface ThreadStats {\n  id: string;\n  name: string;\n  state: string;\n  cpuUsage: number;\n  allocRate: number;\n}\n\nexport interface ProcessSummary {\n  timestamp: number;\n  cpuUsage: number;\n  heapAllocRate: number;\n  threads: ThreadStats[];\n}\n\nfunction parseAllocRate(str: string): number {\n  // Handles values like '11mb/s', '2361kb/s', '1423b/s'\n  const match = str.trim().match(/([\\d.]+)\\s*(mb|kb|b)\\/s/i);\n  if (!match) return 0;\n  const value = parseFloat(match[1]);\n  const unit = match[2].toLowerCase();\n  let bytes = 0;\n  if (unit === 'mb') bytes = value * 1024 * 1024;\n  else if (unit === 'kb') bytes = value * 1024;\n  else if (unit === 'b') bytes = value;\n  // Filter out values above 10,000 MB/s (10,000 * 1024 * 1024 bytes)\n  if (bytes > 10000 * 1024 * 1024) return 0;\n  return bytes;\n}\n\nexport function parseJvmThreadDump(content: string): ProcessSummary[] {\n  const blocks = content.split(/\\n\\s*\\n/).map(b => b.trim()).filter(Boolean);\n  const results: ProcessSummary[] = [];\n\n  for (const block of blocks) {\n    const lines = block.split(/\\n/).map(l => l.trim()).filter(Boolean);\n    if (lines.length < 6) continue;\n\n    // Parse header\n    const timestampMatch = lines[0].match(/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\+\\d{4})/);\n    const cpuMatch = lines[1].match(/process cpu=([\\d.]+)%/);\n    const heapAllocMatch = lines[5].match(/heap allocation rate ([^\\s]+)/i);\n    if (!timestampMatch || !cpuMatch || !heapAllocMatch) continue;\n\n    const timestamp = Date.parse(timestampMatch[1]);\n    const cpuUsage = parseFloat(cpuMatch[1]);\n    const heapAllocRate = parseAllocRate(heapAllocMatch[1]);\n\n    // Parse threads\n    const threads: ThreadStats[] = [];\n    for (let i = 6; i < lines.length; i++) {\n      const threadLine = lines[i];\n      const threadMatch = threadLine.match(/^\\[(\\d+)\\] user=\\s*([\\-\\d.]+)% sys=\\s*([\\-\\d.]+)% alloc=\\s*([^\\s]+) - (.+)$/);\n      if (threadMatch) {\n        const id = threadMatch[1];\n        const userCpu = parseFloat(threadMatch[2]);\n        const sysCpu = parseFloat(threadMatch[3]);\n        const allocRate = parseAllocRate(threadMatch[4]);\n        const name = threadMatch[5].trim();\n        // State is not present, so we can set it as 'UNKNOWN' or parse from name if needed\n        threads.push({\n          id,\n          name,\n          state: 'UNKNOWN',\n          cpuUsage: userCpu + sysCpu,\n          allocRate,\n        });\n      }\n    }\n\n    results.push({\n      timestamp,\n      cpuUsage,\n      heapAllocRate,\n      threads,\n    });\n  }\n\n  return results;\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}